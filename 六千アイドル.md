六千アイドル
======
In this problem, we're given [n.txt](n.txt), a file that contains a bunch of public keys, exponents, and ciphertexts.

When looking at the public keys, I observed that they were very similar, suggesting the primes used to generate the keys are close to each other.

I tried taking the gcd of a few public keys to see if there were any overlap in primes and there was.

Now this problem becomes similar to the picoctf problem Low Entropy.

I created a list of the primes from the public keys, and deciphered the message one by one.

I used the following code:

```python
from fractions import gcd
f = open("n.txt","r")
n = []
c = []
primes = set()
for i in f:
    if i.strip()[:4] == "n = ":
        n.append(int(i.strip()[4:]))
    if i.strip()[:4] == "c = ":
        c.append(int(i.strip()[4:]))
for a in n:
    for b in n:
        if a!=b:
            x = gcd(a,b)
            if x!=1:
                primes.add(x)
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
def solve(p,q,e,c):
    return hex(pow(c,modinv(e,(p-1)*(q-1)),p*q)).replace("L","")[2:].decode("hex")
for i in range(10):
    temp = []
    for a in primes:
        if n[i]%a==0:
            temp.append(a)
    p = temp[0]
    q = temp[1]
    print solve(p,q,65537,c[i])
```

This prints us the flag:
```
tjctf{pp6nh3uqjh2a4karaze0kt70yiq22hkpcdzutyoo4aand40l3or73kehrb8n4ft1zh9g7i00lxss83p083dlwxa70brhl6qagx1s6mq8edozln7urps6cbd6kd01g0kvtzbg5e6nhev394777lhs427cpcmi96dc226hrpqwcl6uji1346jh4cfuz3w9i0m25s5ulkilatyjg7nsbi6jka2mocchqf8jxpfypbocqq1fj4cqgdydys0bt7j3h572bgfq6rt3rdgy2q33zyhgqoj3u3il8gchqg1bof6kmt1fpo1ragzxlx6baqt2u7baw0r77c8k2cb92qmto3kgagb45vmooyz9482btindgjuq7tgiwr10iau1icv1hhtll5zrz4oejyk0h26kfbglx25nvu5m1b1d9pn3x9reev55oaaqqoauep3h3bvh011pxgxfm09kbixxurghbw3r4pntdcqha2g287stdy3tev7op}
```
